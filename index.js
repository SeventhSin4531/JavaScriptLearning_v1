// const myName = "Oleg"
// console.log(myName)
// myName = "23"
// console.log(myName)

/**************************************************************/

// const objA = {a: 10, b: true}
// const copyOfA = objA
// console.log(objA)
// copyOfA.a = 20
// objA.b = false
// console.log(objA)
// copyOfA.c = "huiu"
// console.log(objA)
// console.log(objA.c)

/**************************************************************/

// let a2 = 10
// console.log(a2)
// a3 = undefined
// console.log(a3)

/**************************************************************/

// function a(){
//     console.log("Chort")
// }
// a()

// a = 10

// a()

/**************************************************************/

// const a = () =>{
//     console.log("Chort")
// }
// a()

// a = 20
// a()

// first second third

/**************************************************************/

// const myObj = {
//     first: "1",
// }

// console.log(myObj)
// myObj.second = "2"
// console.log(myObj)
// myObj.third = "3"
// console.log(myObj)

/**************************************************************/

// const unit = {
//     name: "Chaos Space Marine",
//     WS: "3+",
//     BS: "3+",
//     move: 6,
//     Sv: "3+"
// }
// console.log(unit)

// delete unit.move

// console.log(unit)

/**************************************************************/

// const myObj = {
//     first: "1",
// }

// console.log(myObj)

// myObj["second"] = "2"

// console.log(myObj)

/**************************************************************/

// const objName = {

// }

// console.log(objName)

// const firstPropName = "first"
// const secondPropName = "second"
// const thirdPropName = "third"

// objName[firstPropName] = 1
// objName[secondPropName] = 2
// objName[thirdPropName] = 3

// console.log(objName)

/**************************************************************/

// const whUnit = {
//     name: "Plague Marine",
//     information: {
//         WS: "3+",
//         BS: "3+",
//         move: 5,
//         Sv: "3+"
//     }
// }
// console.log(whUnit)
// console.log(whUnit.information)
// console.log(whUnit.information.move)

/**************************************************************/

// const whUnit = {
//     name: "Plague Marine",
//     information: {
//         WS: "3+",
//         BS: "3+",
//         move: 5,
//         Sv: "3+"
//     }
// }

// delete whUnit.information["move"]

// console.log(whUnit)

/**************************************************************/

// const name = "Oleg"
// const age = 25

// const user = {
//     name: name,
//     age: age,
//     id: 101,
//     isKlient: true
// }


// console.log(user)

// let drugoeName = "notOleg " + "Helow"
// let drugoeAge = 24 + 13

// user.name = drugoeName
// user.age = drugoeAge

// console.log(user)

/**************************************************************/

// const name = "Oleg"
// const age = 25

// const user = {
/*Рекомендуется размещать сокращённые свойства в начале объекта, и сортировать их по длине названия*/
//     age,
//     name,
//     id: 101,
//     isKlient: true
// }


// console.log(user)

// let drugoeName = "notOleg " + "Helow"
// let drugoeAge = 24 + 13

// user.name = drugoeName
// user.age = drugoeAge

// console.log(user)

/**************************************************************/

/* глобальные объекты window (в веб-браузерах), global (в node.js) имеют огромное количество свойств, в т.ч. высоту и ширину экрана
(для веб-браузеров). так же существует унифицированное название для глобальных объектов, globalThis*/

// window.innerWidth
// globalThis.innerHeight
// globalThis.console.log(10)

/* метод - свойство объекта, значение которого - функция ******** */

// const myBook = {
//     name: "Всадник без головы",
//     costOfBook: function () {
//         console.log(300)
//     }
// }
// myBook.costOfBook()

/**************************************************************/

// const myBook = {
//     name: "Всадник без головы",
//     costOfBook() {
//         console.log(300)
//     }
// }

// myBook.costOfBook()

/**************************************************************/

// JSON - JavaScript Object Notation
// формат обмена текстовыми данными между компьютерами в интернете
// позволяет хранить и передавать структурированную информацию
// JSON — это текстовый файл, составленный по строгим, но простым правилам.
// Внутри него данные организованы не в виде сплошного текста, а структурированы с помощью пар «ключ-значение» и упорядоченных списков

// пример записи на JSON: ************************

// {
//     "userID": 1,
//     "ID": 1,
//     "title": "Test title",
//     "status": {
//         "complited": false
//     }
// }

// JSON передаёт данные в виде строки:

// {"userID": 1,"ID": 1,"title": "Test title","status": {"complited": false}}

// для того, чтобы превратить JSON в объект JS, используется метод JSON.parse()
// для обратного превращения используется метод JSON.stringify()

// let a1 = {"userID": 1,"ID": 1,"title": "Test title","status": {"complited": false}}
// const b1 = JSON.stringify(a1)
// const c1 = JSON.parse(b1)

// console.log(b1)
// console.log(c1)

// let a1 = '{"userID": 1,"ID": 1,"title": "Test title","status": {"complited": false}}'
// const b1 = JSON.parse(a1)
// console.log(b1)

/************************мутация в JS************************/

// const a = 10

// // копирование по значению (copy by value):

// let b = a

// console.log(b)

// b = 30

// console.log(b)
// console.log(a)

// // мутирование объекта в JS:

// const person = {
//     name: "Test",
//     age: 21
// }

// console.log(person)

// // тут мы поменяли свойства объекта, не меняя ссылку на объект, это и называется мутацией объекта

// person.age = 22
// person.isStariy = true

// console.log(person)

/* ****************************************мутирование копий**************************************** */

// const person = {
//     name: "Test",
//     age: 21
// }
// // "скопировали" объект (на самом деле записали ссылку на один и тот же объект из одной переменной в другую) (copy by reference)
// const person2 = person
// // "поменяли" "копию" объекта (на самом деле нет, не копию, а сам объект)
// person2.age = 36
// person2.isStaryi = true
// // сам объект тоже поменялся, нихуя себе!
// console.log(person)

/* ****************************************как избежать мутаций**************************************** */

// const person = {
//     name: "Test",
//     age: 21
// }

// // с помощью специальной функции (точнее с помощью специального метода объекта Object) можно прям создать копию объекта

// const person2 = Object.assign({}, person) // почитать про эту шнягу подробне

// person2.age = 26
// person2.name = "HUI"
// console.log(person)
// console.log(person2)

// // но при использовании метода assign ВЛОЖЕННЫЕ объекты не копируются, а мутируются, т.е. если у объекта есть вложенные объекты, то ссылки на них СОХРАНЯЮТСЯ

// const bimbus = {
//     test: "Test",
//     isChlen: {
//         da: false,
//         net: true
//     }
// }

// const bimbus2 = Object.assign({}, bimbus)

// bimbus.isChlen.da = true
// bimbus2.test = "Not_Test"
// bimbus2.isChlen.net = false

// console.log(bimbus)
// console.log(bimbus2)

// // и вот такой вывод получим в таком случае:
// // { test: 'Test', isChlen: { da: true, net: false } }
// // { test: 'Not_Test', isChlen: { da: true, net: false } }

/* ****************************************второй способ создания копий объекта**************************************** */

// const person = {
//     name: "Test",
//     age: 21
// }

// // используем оператор разделения объекта на свойства (...)

// const person2 = {...person}

// person2.name = "ЗА РУССА И ВСЕОТЦА!!!"
// person2.age = 40000

// console.log(person)
// console.log(person2)

// // но это по сути одна хуйня, используя такой метод вложенные объекты не скопируешь

// const bimbus = {
//     test: "Test",
//     isChlen: {
//         da: false,
//         net: true
//     }
// }

// const bimbus2 = {...bimbus}

// bimbus.isChlen.da = true
// bimbus2.test = "Not_Test"
// bimbus2.isChlen.net = false

// console.log(bimbus)
// console.log(bimbus2)

// // вывод такой же, как и в первом случае:
// // { test: 'Test', isChlen: { da: true, net: false } }
// // { test: 'Not_Test', isChlen: { da: true, net: false } }

/* ****************************************третий способ создания копий объекта**************************************** */

// // АХАХАХАХАХАХАХ ЕБАТЬ, ЗЫРЬТЕ ЧО
// // вот у нас есть объект нахуй

// const bimbus = {
//     test: "Test",
//     isChlen: {
//         da: false,
//         net: true
//     }
// }

// // и мы такие типо хуяк:

// const bimbus2 = JSON.parse(JSON.stringify(bimbus))

// // поняли нет?) смешно?) мы сначала его короче в строку хуйнули, потом эту строку перепиздрячили в объект, и этот объект в новую переменную записали

// bimbus2.test = "JOPA"
// bimbus.isChlen.da = true
// bimbus2.isChlen.net = false

// console.log(bimbus)
// console.log(bimbus2)

// // и вот такой по итогу у нас вывод получился:
// // { test: 'Test', isChlen: { da: true, net: true } }
// // { test: 'JOPA', isChlen: { da: false, net: false } }

// // так как в первых двух случаях при копировании сохранялись ссылки на вложенные объекты, isChlen был один и тот же каждый раз, а в этом, третьем случае, он тоже копируется, и копия от оригинала не зависит
// // но смешно пиздец)))

/* ********************************************************************************функции******************************************************************************** */

// let a = 5
// let b = 3
// let c

// // но вот так вот делать это кринж ебаный

// c = a + b
// console.log(c)

// a = 8
// b = 12

// // потому что блоки кода повторяются, а это нехорошо

// c = a + b
// console.log(c)

/* ****************************************************************************************************** */

// let a = 5
// let b = 3

// // вот так вот делать нужно:

// function mySum(a, b){
//     const c = a + b /*здесь с это локальная переменная, которая существует только в рамках функции*/
//     console.log(c)
// }

// mySum(a, b) /*тут мы просто вызываем объявленную ранее функцию*/

// a = 123
// b = 321

// mySum(a, b) /*А ВОТ ТУТ ХУЙ ЗНАЕТ ЧТО ПРОИСХОДИТ, ЖЭЭЭСТЬ (шутка, тут тоже просто вызов функции)*/

// // вот теперь заебись, оптимизированно написано
// // разумеется результат работы функции в данном случае зависит от переданных ей в качестве параметров переменных
// // функции позволяют выполнять одни и те же действия с разными вводными значениями

/* ********************************************************************************какие функции бывают******************************************************************************** */

// функция может быть:
// именованной
// присвоена переменной
// анонимной (не иметь названия)
// аргументом при вызове другой функции
// значением свойства (метода) объекта

// функция в JS это ОБЪЕКТ (со всеми вытекающими)

// ключевое слово return позволяет вернуть результат работы функции, для того, чтобы у нас была возможность записать результат в куда-нибудь
// (в переменную, в список, в массив, в маму разработчика, хз, придумай там что-нибудь)

// function mySum(a, b){
//     const c = a + b
//     return c
// }

// let param1 = 100
// let param2 = 500

// const param3 = mySum(param1, param2) /*здесь как раз происходит запись результата работы функции в переменную*/

// console.log(param3) /*ну и вывод офк*/

// если в теле функции отсутствует ключевое слово return, то функция возвращает undefined

/* ********************************************************************************вызовы функций******************************************************************************** */

// // объявление функции myFn, a и b параметры

// function myFn(a, b){
//     a = a + 1
//     let c = a + b
//     return c
// }

// // 2 способа вызова функций

// let a = myFn(10, 20) /* 10 и 20 - аргументы*/

// console.log(a)
// console.log(myFn(20, 30))

// function g(){} /* самая короткая функция */
// console.log(g())

/* ********************************************************************************передача значения по ссылке******************************************************************************** */

// const personOne = {
//     name: "Bob",
//     age: 21
// }

// // в этом случае функция мутирует внешний объект, т.к. person и personOne ссылаются на один и тот же объект, а это хуёво
// // внутри функции не рекомендуется мутировать внешние объекты

// function isLoh(person){
//     person.age += 1
//     return person
// }

// const newPersonOne = isLoh(personOne)
// console.log(personOne.age)      //22
// console.log(newPersonOne.age)   //22

/* ********************************************************************************как бороться с мутированием объектов в функции******************************************************************************** */

// const personOne = {
//     name: "Bob",
//     age: 21
// }

// // вот тут мы в функции создаём новый объект (newPerson), копируем в него данные из старого объекта-параметра (person)
// // с помощью специальной функции (Object.assign()), и изменяем уже новый объект, не трогая при этом старый

// function isLoh(person){
//     const newPerson = Object.assign({}, person)
//     newPerson.age += 1
//     return newPerson
// }

// const newPersonOne = isLoh(personOne)

// console.log(personOne.age)      //21
// console.log(newPersonOne.age)   //22

// // но иногда функции специально создаются таким образом, чтобы они меняли внешние объекты, а не их копии

/* ********************************************************************************колбэк функции******************************************************************************** */

// колбэк функции - это такие функции, которые вызываются другими функциями

// function printTest() {
//     console.log("Test")
// }

// console.log("Start")

// setTimeout(printTest, 2000)

/* ********************************************************************************области видимости******************************************************************************** */

// // область видимости переменной определяет границы действия переменной
// // какие области видимости бывают:
// // 1) глобальная область видимости
// // 2) локальная область видимости
// // если в глобальной области видимости и в локальной области видимости объявляются переменные с одинаковыми именами, то это будут РАЗНЫЕ переменные

// // пример:
// // Глобальная область видимости
// // {
// //     переменные: а, б, в
// //     Локальная область видимости 1
// //     {
// //         переменные: а, в
// //     }
// //     Локальная область видимости 2
// //     {
// //         переменные: б
// //     }
// // }

// // если мы попытаемся что-то сделать с переменной б, находясь при этом в ЛОВ2, то тогда мы будем работать с переменной б, объявленной в ЛОВ2, не с переменной б из ГОВ
// // но если, находясь в ЛОВ1, мы попытаемся что-то сделать с переменной б (прочитать, изменить и т.д.), то тогда мы будем работать с переменной б, объявленной в ГОВ

// // практический пример:

// let a           //глобальная переменная
// let b           //глобальная переменная

// function myFn() {
//     let b       //локальная переменная (область видимости функции)
//     a = true    //глобальная переменная
//     b = 10
//     console.log(b)
// }

// myFn()          //10

// console.log(a)  //true
// console.log(b)  //undefined

/* ********************************************************************************цепочка областей видимости******************************************************************************** */

// const a = 5

// function myFn() {
//     function innerFn() {
//         console.log(a)
//     }
//     innerFn()
// }

// myFn()
// // innerFn() // ReferenceError: innerFn is not defined ))) (потому что в глобальной области видимости не существует innerFn)
// // кстати результатом вызова функции myFn() будет undefined

/* ********************************************************************************жизненный цикл переменных******************************************************************************** */

// let a           //глобальная переменная (undefined)
// let b           //глобальная переменная (undefined)

// function myFn() {
//     let b       //локальная переменная (область видимости функции myFn())
//     a = true    //глобальная переменная (так как в области видимости вункции myFn() переменная а не была найдена,
//                 //новое значение присваивается глобальной переменной а, потому что функция myFn() так же вызывается в глобальной области видимости)
//     b = 10      //так как переменная b объявлена внутри области видимости функции myFn(), то здесь меняется значение именно этой переменной b, той, которая объявлена внутри области видимости функции myFn()
//     console.log(b)
// }

// myFn()          //10 (после вызова функции все переменные, созданные внутри неё, уничтожаются)

// console.log(a)  //true
// console.log(b)  //undefined

// // для каждого вызова одной и той же функции создаётся новая область видимости*
// // не рекомендуется менять глобальные объекты внутри функций

/* ********************************************************************************типы областей видимости******************************************************************************** */

// // 1) глобальная область видимости
// // 2) область видимости функции
// // 3)область видимости блока (переменные, ообъявленные с пом. let или const внутри блока имеют область видимости, ограниченную этим блоком (блок в JS это любой код, ограниченный {}))

// // вот тут кстати прикол: переменная а нигде не была объявлена, но в теле функции ей присваивается значение

// function myFn() {
//     a = true
//     console.log(a)
// }

// // после вызова функции переменная а будет создана автоматически в глобальной области видимости, но писать такой зашкварный код - это какой-то пазор

// myFn()

// console.log(a)

/* ********************************************************************************правила работы с переменными******************************************************************************** */

// // 1) все переменные ОБЪЯВЛЯТЬ перед их использованием
// // 2) использовать const ВЕЗДЕ, где это возможно
// // 3) внутри функций не изменять переменные с внешних областей видимости

// 'use strict' /* включение строгого режима */

// // строгий режим делает много чего, в том числе запрещает использовать необъявленные переменные
// // кстати эту хуйню можно и внутрь функции запиздрячить, шоб она только там работала

// function myFn() {
//     a = true        //вот тут он тебя нахуй пошлёт)))0)
//     console.log(a)
// }

// myFn()

// console.log(a)

/* ********************************************************************************операторы******************************************************************************** */

// // оператор это встроенная функция

// // виды операторов:
// // 1) арифметические: +, -, *, /
// // 2) сравнения === (равно), !== (не равно), <= >=
// // 3) логические ! && ||
// // 4) присваивания =

// // всё вышеперечисленное - это так называемые "символьные" операторы, но так же существует множество текстовых операторов, например:
// // typeof       (проверяет тип того или иного значения)
// // instanceof   (проверяет принадлежность объекта классу)
// // new          (используется для создания экземпляра объекта, который содержит функцию-конструктор)
// // delete       (удаляет свойство объекта)

// // унарные операторы: (один операнд)
// // +а (вроде как с помощью такой штуки можно перевести строку в число)
// // delete obj.a
// // typeof a
// // new Object()

// let a = "123"
// console.log(+a * 2)
// console.log(+"5" * 2)

// // бинарные операторы: (два операнда)
// // а = с
// // а + с
// // с += а
// // а === с (сравнивает и тип, и значение ("5" === 5 {false}))
// // а && с

// console.log("abc" === "ABC") // false

/* ********************************************************************************форматы записи операторов******************************************************************************** */

// // инфиксная запись/формат: (оператор МЕЖДУ операндами)

// // a = true
// // a + b
// // a += 5
// // a || b
// // a > b

// // префиксная запись: (оператор ПЕРЕД операндом)

// // ++a
// // delete obj.a
// // typeof a

// // постфиксная запись: (оператор ПОСЛЕ операнда)

// // a++
// // myFnc()

/* ********************************************************************************приоритетность операторов******************************************************************************** */

// a + b * c / d - e // тут как в арифметике
// меняется приоритетность естественно с помощью скобок, вот таких: () 

/* ********************************************************************************логические операторы******************************************************************************** */

// 1)  !   (не)     всегда возвращает boolean
// 2)  &&  (и)      возвращает значение одного из операндов
// 3)  ||  (или)    возвращает значение одного из операндов

// ложные значения - это те, которые при приведении типов к логическому типу дают false
// Boolean(value) - приводит значение value к логическому типу

// вставка кода из браузера:

// let isUndefined
// undefined
// typeof isUndefined
// 'undefined'
// typeof isUndefined === "undefined"

/* ********************************************************************************примеры******************************************************************************** */

// /* ОПЕРАТОР НЕ (!) */

// // 1)!10           // false (10 - это не ложное значение)
// // 2)!0            // true
// // 3)!"abc"        // false
// // 4)!""           // true
// // 5)!true         // false
// // 6)!undefined    // true

// const myObj = {}

// // используя !! проверим, пустой объект - это истинное или ложное значение?

// console.log(!!myObj)

// // истинное)
// // это кстати 2 эквивалентных вывода если что

// console.log(Boolean(myObj))

// // операторы И и ИЛИ являются операторами короткого замыкания

// /* ОПЕРАТОР И (&&) */

// // выражение_1 && выражение_2

// // если выражение_1 ложно:
// // выражение_2 игнорируется (в смысле совсем, вообще, даже не читается)
// // возвращается результат выражения_1

// // если выражение_1 истинно:
// // выражение_2 оценивается;

// // если выражение_2 ложно:
// // возвращается результат выражения_2

// // если выражение_2 истинно:
// // возвращается результат выражения_2)))))))))))))))

// /* ОПЕРАТОР ИЛИ (||) */

// // выражение_1 || выражение_2

// // если результат выражения_1 истинно:
// // выражение_2 игнорируется
// // возвращается результат выражения_1

// // если результат выражения_1 ложно:
// // выражение_2 оценивается;

// // если выражение_2 истинно:
// // возвращается результат выражения_2

// // если выражение_2 ложно:
// // возвращается результат выражения_2)))))))))))))))

// // а вот тут кстати прикол:

// let b = 10
// b && console.log("Выполнено!")  /* вывод: Выполнено! */
// let c
// c && console.log("Выполнено!")  /* вывод: undefined */

// // почему так происходит?
// // потому что такая конструкция по сути своей представляет что-то вроде урезанной условной конструкции if else
// // оператор && сначала смотрит на первое выражение (слева), если оно ложно - выводит его значение, если слева тру, смотрит на второе выражение (справа), и выводит его значение в любом случае
// // грубо говоря, && ищет ложь

// b || console.log("Выполнено!")  /* вывод: 10 */
// c || console.log("Выполнено!")  /* вывод: Выполнено! */

// // по аналогии, оператор || ищет правду
// // слева тру? выведи его
// // ложь? смотрим второе выражение, выводим его значение

// // таким образом, используя такой подход, мы можем условно вызывать ЛЮБЫЕ функции, в зависимости от результата той или иной переменной (которую в свою очередь может возвращать другая функция)

/* ********************************************************************************оператор разделения объекта на свойства******************************************************************************** */

// const button = {
//     width: 200,
//     text: "Kupi",
// }

// const redButton = {
//     ...button,
//     color: "red"
// }

// console.table(redButton)

// // в вышеописанном случае redButton возьмёт из button  все его свойства, прихуячит к ним свойство color, и запиздрячит его в новый объект redButton

// // а что будет, если свойство color уже прихуячено к button?

// const button = {
//     width: 200,
//     text: "Kupi",
//     color: "green"
// }

// const redButton = {
//     ...button,
//     color: "red"
// }

// console.table(button)
// console.table(redButton)

// // свойство color в redButton (вернее его значение) будет перезаписано, и станет равно "red"

// // но в этом случае важна последовательность записи, пушо если сначала задать объекту свойство,
// // а потом перезаписать его из другого объекта с помощью ..., то оно будет перезаписано (ни ху я себе, если перезаписывать, то будет перезаписано, никогда такого не было и вот опять)

const button = {
    width: 200,
    text: "Kupi",
    color: "green"
}

const redButton = {
    color: "red",
    ...button,
}

console.table(button)
console.table(redButton)

// такая вот хуйня короче, вот)